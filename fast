GIT-PUSH(1)                       Git Manual                       GIT-PUSH(1)

NNAAMMEE
       git-push - Update remote refs along with associated objects

SSYYNNOOPPSSIISS
       _g_i_t _p_u_s_h [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
                  [--repo=<repository>] [-f | --force] [--prune] [-v | --verbose]
                  [-u | --set-upstream]
                  [--[no-]signed|--sign=(true|false|if-asked)]
                  [--force-with-lease[=<refname>[:<expect>]]]
                  [--no-verify] [<repository> [<refspec>...]]

DDEESSCCRRIIPPTTIIOONN
       Updates remote refs using local refs, while sending objects necessary
       to complete the given refs.

       You can make interesting things happen to a repository every time you
       push into it, by setting up _h_o_o_k_s there. See documentation for ggiitt--
       rreecceeiivvee--ppaacckk(1).

       When the command line does not specify where to push with the
       <repository> argument, branch.*.remote configuration for the current
       branch is consulted to determine where to push. If the configuration is
       missing, it defaults to _o_r_i_g_i_n.

       When the command line does not specify what to push with <refspec>...
       arguments or --all, --mirror, --tags options, the command finds the
       default <refspec> by consulting remote.*.push configuration, and if it
       is not found, honors push.default configuration to decide what to push
       (See ggiitt--ccoonnffiigg(1) for the meaning of push.default).

       When neither the command-line nor the configuration specify what to
       push, the default behavior is used, which corresponds to the simple
       value for push.default: the current branch is pushed to the
       corresponding upstream branch, but as a safety measure, the push is
       aborted if the upstream branch does not have the same name as the local
       one.

OOPPTTIIOONNSS
       <repository>
           The "remote" repository that is destination of a push operation.
           This parameter can be either a URL (see the section GIT URLS below)
           or the name of a remote (see the section REMOTES below).

       <refspec>...
           Specify what destination ref to update with what source object. The
           format of a <refspec> parameter is an optional plus +, followed by
           the source object <src>, followed by a colon :, followed by the
           destination ref <dst>.

           The <src> is often the name of the branch you would want to push,
           but it can be any arbitrary "SHA-1 expression", such as master~4 or
           HEAD (see ggiittrreevviissiioonnss(7)).

           The <dst> tells which ref on the remote side is updated with this
           push. Arbitrary expressions cannot be used here, an actual ref must
           be named. If git push [<repository>] without any <refspec> argument
           is set to update some ref at the destination with <src> with
           remote.<repository>.push configuration variable, :<dst> part can be
           omitted—such a push will update a ref that <src> normally updates
           without any <refspec> on the command line. Otherwise, missing
           :<dst> means to update the same ref as the <src>.

           The object referenced by <src> is used to update the <dst>
           reference on the remote side. By default this is only allowed if
           <dst> is not a tag (annotated or lightweight), and then only if it
           can fast-forward <dst>. By having the optional leading +, you can
           tell Git to update the <dst> ref even if it is not allowed by
           default (e.g., it is not a fast-forward.) This does nnoott attempt to
           merge <src> into <dst>. See EXAMPLES below for details.

           tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>.

           Pushing an empty <src> allows you to delete the <dst> ref from the
           remote repository.

           The special refspec : (or +: to allow non-fast-forward updates)
           directs Git to push "matching" branches: for every branch that
           exists on the local side, the remote side is updated if a branch of
           the same name already exists on the remote side.

       --all
           Push all branches (i.e. refs under refs/heads/); cannot be used
           with other <refspec>.

       --prune
           Remove remote branches that don’t have a local counterpart. For
           example a remote branch tmp will be removed if a local branch with
           the same name doesn’t exist any more. This also respects refspecs,
           e.g.  git push --prune remote refs/heads/*:refs/tmp/* would make
           sure that remote refs/tmp/foo will be removed if refs/heads/foo
           doesn’t exist.

       --mirror
           Instead of naming each ref to push, specifies that all refs under
           refs/ (which includes but is not limited to refs/heads/,
           refs/remotes/, and refs/tags/) be mirrored to the remote
           repository. Newly created local refs will be pushed to the remote
           end, locally updated refs will be force updated on the remote end,
           and deleted refs will be removed from the remote end. This is the
           default if the configuration option remote.<remote>.mirror is set.

       -n, --dry-run
           Do everything except actually send the updates.

       --porcelain
           Produce machine-readable output. The output status line for each
           ref will be tab-separated and sent to stdout instead of stderr. The
           full symbolic names of the refs will be given.

       --delete
           All listed refs are deleted from the remote repository. This is the
           same as prefixing all refs with a colon.

       --tags
           All refs under refs/tags are pushed, in addition to refspecs
           explicitly listed on the command line.

       --follow-tags
           Push all the refs that would be pushed without this option, and
           also push annotated tags in refs/tags that are missing from the
           remote but are pointing at commit-ish that are reachable from the
           refs being pushed. This can also be specified with configuration
           variable _p_u_s_h_._f_o_l_l_o_w_T_a_g_s. For more information, see _p_u_s_h_._f_o_l_l_o_w_T_a_g_s
           in ggiitt--ccoonnffiigg(1).

       --[no-]signed, --sign=(true|false|if-asked)
           GPG-sign the push request to update refs on the receiving side, to
           allow it to be checked by the hooks and/or be logged. If false or
           --no-signed, no signing will be attempted. If true or --signed, the
           push will fail if the server does not support signed pushes. If set
           to if-asked, sign if and only if the server supports signed pushes.
           The push will also fail if the actual call to gpg --sign fails. See
           ggiitt--rreecceeiivvee--ppaacckk(1) for the details on the receiving end.

       --[no-]atomic
           Use an atomic transaction on the remote side if available. Either
           all refs are updated, or on error, no refs are updated. If the
           server does not support atomic pushes the push will fail.

       --receive-pack=<git-receive-pack>, --exec=<git-receive-pack>
           Path to the _g_i_t_-_r_e_c_e_i_v_e_-_p_a_c_k program on the remote end. Sometimes
           useful when pushing to a remote repository over ssh, and you do not
           have the program in a directory on the default $PATH.

       --[no-]force-with-lease, --force-with-lease=<refname>,
       --force-with-lease=<refname>:<expect>
           Usually, "git push" refuses to update a remote ref that is not an
           ancestor of the local ref used to overwrite it.

           This option overrides this restriction if the current value of the
           remote ref is the expected value. "git push" fails otherwise.

           Imagine that you have to rebase what you have already published.
           You will have to bypass the "must fast-forward" rule in order to
           replace the history you originally published with the rebased
           history. If somebody else built on top of your original history
           while you are rebasing, the tip of the branch at the remote may
           advance with her commit, and blindly pushing with --force will lose
           her work.

           This option allows you to say that you expect the history you are
           updating is what you rebased and want to replace. If the remote ref
           still points at the commit you specified, you can be sure that no
           other people did anything to the ref. It is like taking a "lease"
           on the ref without explicitly locking it, and the remote ref is
           updated only if the "lease" is still valid.

           --force-with-lease alone, without specifying the details, will
           protect all remote refs that are going to be updated by requiring
           their current value to be the same as the remote-tracking branch we
           have for them.

           --force-with-lease=<refname>, without specifying the expected
           value, will protect the named ref (alone), if it is going to be
           updated, by requiring its current value to be the same as the
           remote-tracking branch we have for it.

           --force-with-lease=<refname>:<expect> will protect the named ref
           (alone), if it is going to be updated, by requiring its current
           value to be the same as the specified value <expect> (which is
           allowed to be different from the remote-tracking branch we have for
           the refname, or we do not even have to have such a remote-tracking
           branch when this form is used).

           Note that all forms other than
           --force-with-lease=<refname>:<expect> that specifies the expected
           current value of the ref explicitly are still experimental and
           their semantics may change as we gain experience with this feature.

           "--no-force-with-lease" will cancel all the previous
           --force-with-lease on the command line.

       -f, --force
           Usually, the command refuses to update a remote ref that is not an
           ancestor of the local ref used to overwrite it. Also, when
           --force-with-lease option is used, the command refuses to update a
           remote ref whose current value does not match what is expected.

           This flag disables these checks, and can cause the remote
           repository to lose commits; use it with care.

           Note that --force applies to all the refs that are pushed, hence
           using it with push.default set to matching or with multiple push
           destinations configured with remote.*.push may overwrite refs other
           than the current branch (including local refs that are strictly
           behind their remote counterpart). To force a push to only one
           branch, use a + in front of the refspec to push (e.g git push
           origin +master to force a push to the master branch). See the
           <refspec>...  section above for details.

       --repo=<repository>
           This option is equivalent to the <repository> argument. If both are
           specified, the command-line argument takes precedence.

       -u, --set-upstream
           For every branch that is up to date or successfully pushed, add
           upstream (tracking) reference, used by argument-less ggiitt--ppuullll(1)
           and other commands. For more information, see _b_r_a_n_c_h_._<_n_a_m_e_>_._m_e_r_g_e
           in ggiitt--ccoonnffiigg(1).

       --[no-]thin
           These options are passed to ggiitt--sseenndd--ppaacckk(1). A thin transfer
           significantly reduces the amount of sent data when the sender and
           receiver share many of the same objects in common. The default is
           --thin.

       -q, --quiet
           Suppress all output, including the listing of updated refs, unless
           an error occurs. Progress is not reported to the standard error
           stream.

       -v, --verbose
           Run verbosely.

       --progress
           Progress status is reported on the standard error stream by default
           when it is attached to a terminal, unless -q is specified. This
           flag forces progress status even if the standard error stream is
           not directed to a terminal.

       --no-recurse-submodules, --recurse-submodules=check|on-demand|no
           May be used to make sure all submodule commits used by the
           revisions to be pushed are available on a remote-tracking branch.
           If _c_h_e_c_k is used Git will verify that all submodule commits that
           changed in the revisions to be pushed are available on at least one
           remote of the submodule. If any commits are missing the push will
           be aborted and exit with non-zero status. If _o_n_-_d_e_m_a_n_d is used all
           submodules that changed in the revisions to be pushed will be
           pushed. If on-demand was not able to push all necessary revisions
           it will also be aborted and exit with non-zero status. A value of
           _n_o or using _-_-_n_o_-_r_e_c_u_r_s_e_-_s_u_b_m_o_d_u_l_e_s can be used to override the
           push.recurseSubmodules configuration variable when no submodule
           recursion is required.

       --[no-]verify
           Toggle the pre-push hook (see ggiitthhooookkss(5)). The default is
           --verify, giving the hook a chance to prevent the push. With
           --no-verify, the hook is bypassed completely.

GGIITT UURRLLSS
       In general, URLs contain information about the transport protocol, the
       address of the remote server, and the path to the repository. Depending
       on the transport protocol, some of this information may be absent.

       Git supports ssh, git, http, and https protocols (in addition, ftp, and
       ftps can be used for fetching and rsync can be used for fetching and
       pushing, but these are inefficient and deprecated; do not use them).

       The native transport (i.e. git:// URL) does no authentication and
       should be used with caution on unsecured networks.

       The following syntaxes may be used with them:

       ·   ssh://[user@]host.xz[:port]/path/to/repo.git/

       ·   git://host.xz[:port]/path/to/repo.git/

       ·   http[s]://host.xz[:port]/path/to/repo.git/

       ·   ftp[s]://host.xz[:port]/path/to/repo.git/

       ·   rsync://host.xz/path/to/repo.git/

       An alternative scp-like syntax may also be used with the ssh protocol:

       ·   [user@]host.xz:path/to/repo.git/

       This syntax is only recognized if there are no slashes before the first
       colon. This helps differentiate a local path that contains a colon. For
       example the local path foo:bar could be specified as an absolute path
       or ./foo:bar to avoid being misinterpreted as an ssh url.

       The ssh and git protocols additionally support ~username expansion:

       ·   ssh://[user@]host.xz[:port]/~[user]/path/to/repo.git/

       ·   git://host.xz[:port]/~[user]/path/to/repo.git/

       ·   [user@]host.xz:/~[user]/path/to/repo.git/

       For local repositories, also supported by Git natively, the following
       syntaxes may be used:

       ·   /path/to/repo.git/

       ·   file:///path/to/repo.git/

       These two syntaxes are mostly equivalent, except when cloning, when the
       former implies --local option. See ggiitt--cclloonnee(1) for details.

       When Git doesn’t know how to handle a certain transport protocol, it
       attempts to use the _r_e_m_o_t_e_-_<_t_r_a_n_s_p_o_r_t_> remote helper, if one exists. To
       explicitly request a remote helper, the following syntax may be used:

       ·   <transport>::<address>

      